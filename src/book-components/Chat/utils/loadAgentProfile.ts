import { generatePlaceholderAgentProfileImageUrl } from '../../../_packages/core.index';
import type { string_url, string_url_image } from '../../../types/typeAliases';

/**
 * Input data for resolving agent profiles.
 * @private
 */
export type AgentProfileInput = {
    url: string_url;
    label?: string;
    imageUrl?: string_url_image;
    publicUrl?: string_url;
};

/**
 * Resolved agent profile data for UI usage.
 * @private
 */
export type AgentProfileData = {
    label: string;
    imageUrl: string_url_image | null;
};

/**
 * Minimal agent profile payload from the profile endpoint.
 */
type AgentProfilePayload = {
    agentName?: string;
    meta?: {
        fullname?: string;
        image?: string_url_image;
    };
};

const profileCache = new Map<string, AgentProfileData>();
const profilePromiseCache = new Map<string, Promise<AgentProfileData>>();

/**
 * Minimum length threshold for treating labels as generated IDs.
 */
const GENERATED_ID_MIN_LENGTH = 12;

/**
 * Builds a cache key for agent profile requests.
 */
function buildProfileCacheKey(agent: AgentProfileInput): string {
    return agent.publicUrl ? `${agent.url}|${agent.publicUrl}` : agent.url;
}

/**
 * Extracts agent name from URL.
 * @private
 */
export function extractAgentNameFromUrl(url: string): string {
    try {
        const urlObj = new URL(url);
        const pathParts = urlObj.pathname.split('/').filter(Boolean);
        return pathParts[pathParts.length - 1] || urlObj.hostname;
    } catch {
        return url;
    }
}

/**
 * Determines whether a label looks like an autogenerated identifier.
 * @private
 */
export function isLikelyGeneratedId(label: string): boolean {
    const trimmed = label.trim();
    if (!trimmed) {
        return false;
    }

    const hasSeparators = /[\s_-]/.test(trimmed);
    const hasDigits = /\d/.test(trimmed);
    const hasMixedCase = /[a-z]/.test(trimmed) && /[A-Z]/.test(trimmed);
    const isLong = trimmed.length >= GENERATED_ID_MIN_LENGTH;

    return !hasSeparators && (hasDigits || (hasMixedCase && isLong));
}

/**
 * Resolves the initial label for an agent without exposing generated IDs.
 * @private
 */
export function resolveInitialAgentLabel(agent: AgentProfileInput): string {
    const candidate = (agent.label || extractAgentNameFromUrl(agent.url)).trim();
    if (!candidate || isLikelyGeneratedId(candidate)) {
        return 'Teammate';
    }

    return candidate;
}

/**
 * Picks the best available label from profile data without exposing IDs.
 * @private
 */
export function resolvePreferredAgentLabel(candidates: Array<string | undefined>, fallback: string): string {
    for (const candidate of candidates) {
        const trimmed = candidate?.trim();
        if (trimmed && !isLikelyGeneratedId(trimmed)) {
            return trimmed;
        }
    }

    return fallback;
}

/**
 * Resolves the agents server base URL from the agent URL or provided public URL.
 * @private
 */
export function resolveAgentsServerUrl(agentUrl: string, publicUrl?: string_url): string | null {
    try {
        if (publicUrl) {
            return new URL(publicUrl).href;
        }

        const url = new URL(agentUrl);
        return `${url.origin}/`;
    } catch {
        return null;
    }
}

/**
 * Resolves the profile image URL, handling relative URLs when needed.
 * @private
 */
export function resolveProfileImageUrl(
    profileImageUrl: string_url_image | undefined,
    agentUrl: string_url,
    publicUrl?: string_url,
): string_url_image | null {
    if (!profileImageUrl) {
        return null;
    }

    if (profileImageUrl.startsWith('http://') || profileImageUrl.startsWith('https://')) {
        return profileImageUrl;
    }

    const baseUrl = resolveAgentsServerUrl(agentUrl, publicUrl);
    if (!baseUrl) {
        return profileImageUrl;
    }

    try {
        return new URL(profileImageUrl, baseUrl).href as string_url_image;
    } catch {
        return profileImageUrl;
    }
}

/**
 * Builds a placeholder image URL for the agent when no profile image is available.
 * @private
 */
export function resolvePlaceholderImageUrl(agent: AgentProfileInput): string_url_image | null {
    const baseUrl = resolveAgentsServerUrl(agent.url, agent.publicUrl);
    if (!baseUrl) {
        return null;
    }

    const agentName = extractAgentNameFromUrl(agent.url);
    return generatePlaceholderAgentProfileImageUrl(agentName, baseUrl);
}

/**
 * Returns true when a profile fetch would likely improve the label or image.
 * @private
 */
export function shouldFetchAgentProfile(agent: AgentProfileInput): boolean {
    return !agent.imageUrl || !agent.label || isLikelyGeneratedId(agent.label);
}

/**
 * Resolves fallback profile data without fetching remote metadata.
 * @private
 */
export function resolveAgentProfileFallback(agent: AgentProfileInput): AgentProfileData {
    const label = resolveInitialAgentLabel(agent);
    const imageUrl = agent.imageUrl || resolvePlaceholderImageUrl(agent);

    return {
        label,
        imageUrl: imageUrl || null,
    };
}

/**
 * Loads agent profile data from the agent profile endpoint when needed.
 * @private
 */
export async function loadAgentProfile(agent: AgentProfileInput): Promise<AgentProfileData> {
    const cacheKey = buildProfileCacheKey(agent);
    const cached = profileCache.get(cacheKey);
    if (cached) {
        return cached;
    }

    const pending = profilePromiseCache.get(cacheKey);
    if (pending) {
        return pending;
    }

    const fallback = resolveAgentProfileFallback(agent);

    const request = (async () => {
        if (!shouldFetchAgentProfile(agent)) {
            return fallback;
        }

        try {
            const profileUrl = `${agent.url.replace(/\/$/, '')}/api/profile`;
            const response = await fetch(profileUrl);

            if (!response.ok) {
                return fallback;
            }

            const profile = (await response.json()) as AgentProfilePayload;
            const label = resolvePreferredAgentLabel(
                [profile.meta?.fullname, profile.agentName, agent.label, extractAgentNameFromUrl(agent.url)],
                fallback.label,
            );
            const imageUrl =
                resolveProfileImageUrl(profile.meta?.image, agent.url, agent.publicUrl) || fallback.imageUrl;

            return {
                label,
                imageUrl: imageUrl || null,
            };
        } catch (error) {
            console.warn('Failed to fetch agent profile:', error);
            return fallback;
        }
    })();

    profilePromiseCache.set(cacheKey, request);

    const resolved = await request;
    profilePromiseCache.delete(cacheKey);
    profileCache.set(cacheKey, resolved);

    return resolved;
}
