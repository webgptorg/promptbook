import { ParseError } from '../../errors/ParseError';
import type { $PipelineJson,$TaskJson } from '../_common/types/CommandParser';
import type { $PipelineJson,$TaskJson } from '../_common/types/CommandParser';
import type { string_markdown_text } from '../../types/typeAliases';
import type { Command } from './types/Command';
import type { CommandUsagePlace } from './types/CommandUsagePlaces';

/**
 * Parses one line of ul/ol to command and applies it to given `pipelineJson`
 *
 * Note: `$` is used to indicate that this function mutates given `pipelineJson`
 *
 * @returns parsed command object
 * @throws {ParseError} if the command is invalid or something went wrong during applying the command
 *
 * @private within the compilePipeline
 */
export function $parseAndApplyPipelineHeadCommands(raw: string_markdown_text, $pipelineJson: $PipelineJson ): $side_effect {}

/**
 * TODO: [ðŸ¥¥] Maybe implement this function
 * TODO: [ðŸ¥¥] DRY `$parseAndApplyPipelineHeadCommands` and `$parseAndApplyPipelineTaskCommands`
 */
