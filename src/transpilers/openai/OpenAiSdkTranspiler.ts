import { spaceTrim } from 'spacetrim';
import { TODO_any } from '../../_packages/types.index';
import { compilePipeline } from '../../conversion/compilePipeline';
import type { PipelineJson } from '../../pipeline/PipelineJson/PipelineJson';
import type { TaskJson } from '../../pipeline/PipelineJson/TaskJson';
import type { PipelineString } from '../../pipeline/PipelineString';
import { TODO_USE } from '../../utils/organization/TODO_USE';
import type { BookTranspilerDefinition } from '../_common/BookTranspilerDefinition';

/**
 * Transpiler to Javascript code using OpenAI SDK.
 *
 * @private TODO: !!!! Which package should export this?
 */
export const OpenAiSdkTranspiler: BookTranspilerDefinition = {
    name: 'openai-sdk',
    title: 'OpenAI SDK',
    // TODO: [ðŸ§ ] packageName and className
    packageName: '@promptbook/openai-sdk-transpiler',
    className: 'OpenAiSdkTranspiler',
    new: (tools) => async (book, _options) => {
        TODO_USE(_options);

        const pipeline = await compilePipeline(book as PipelineString, tools);

        const anouncement = spaceTrim(
            () => `
                /**
                 * This code was generated by Promptbook
                 * @see https://promptbook.studio
                 *
                 * From book: ${pipeline.pipelineUrl}
                 *
                 * WARNING: This code is experimental and may not work as expected.
                 */
            `,
        );

        const imports = spaceTrim(
            () => `
                import { OpenAI } from 'openai';
            `,
        );

        const functions = pipeline.tasks.map((template) => transpileTemplate(template, pipeline));

        return spaceTrim(
            () => `
                ${anouncement}

                ${imports}

                ${functions.join('\n\n')}
            `,
        );
    },
};

function transpileTemplate(template: TaskJson, pipeline: PipelineJson): string {
    // TODO: Better template type detection
    if (
        (template as TODO_any).taskType === 'PROMPT_TEMPLATE' &&
        (template as TODO_any).modelRequirements.modelVariant === 'CHAT'
    ) {
        // TODO: DRY
        const functionName = template.name;
        const parameters = pipeline.parameters.filter((parameter) => parameter.isInput);
        const parameterNames = parameters.map((parameter) => parameter.name);
        const parameterNamesAndTypes = parameterNames.map((name) => `${name}: string`).join(', ');
        const interpolatedContent = interpolateTemplate((template as TODO_any).content, parameterNames);

        return spaceTrim(
            () => `
                export async function ${functionName}({ ${parameterNames.join(', ')} }: { ${parameterNamesAndTypes} }) {
                    const openai = new OpenAI({
                        apiKey: process.env.OPENAI_API_KEY,
                    });
                    const chatCompletion = await openai.chat.completions.create({
                        messages: [
                            {
                                role: 'user',
                                content: ${interpolatedContent},
                            },
                        ],
                        model: '${(template as TODO_any).modelRequirements.modelName}',
                    });
                    return chatCompletion.choices[0].message.content;
                }
            `,
        );
    } else {
        return `// TODO: ${(template as TODO_any).taskType} templates are not implemented yet`;
    }
}

function interpolateTemplate(template: string, parameterNames: string[]): string {
    let result = template;
    for (const parameterName of parameterNames) {
        result = result.replace(new RegExp(`{${parameterName}}`, 'g'), `\${${parameterName}}`);
    }
    return `\`${result}\``;
}

/**
 * TODO: [ðŸ§ ] What should be the scope of the transpiled code?
 * - Just a single function?
 * - A class?
 * - A whole package?
 */
